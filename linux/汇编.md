### 常见命令
```sh
# 根据机器代码产生一种类似于汇编代码的格式
linux/window> objdump -d hello.o
# GDB 调试工具
(gdb) x/14xb hello

# c语言编译器产生的汇编代码，生成hello.s文件
>gcc -Og -S hello.c

# 产生目标文件hello.o
>gcc -Og -c hello.c

# GCC产生Intel格式的代码
>gcc -Og -S -masm=intel hello.c
```
### 基本概念
* `pushl` - push long数据类型
* 以 `.`开头的都是知道汇编器和链接器工作的伪指令，通常可以忽略掉
* `pushq` - `q`是大小指示符  
  `movb` (传送字节) `movw` (传送字)
* 使用`asm`伪指令可以在C程序中包含剪短的汇编代码
* Intel用术语"字(word)"表示16位数据类型，因此，32位数为双字(double words),64位为“四字(quad words)”

### 数据格式
|C声明|Intel数据类型|汇编代码后缀|大小(字节)
|-----|------------|-----------|---------
|char|字节|b|1
|short|字|w|2
|int|双字|l|4
|long|四字|q|8
|char *|四字|q|8
|float|单精度|s|4
|double|双精度|l|8

### 访问信息
* 通用目的寄存器 - 16个存储64位值，存储整数数据和指针 `%r` - 开头
![整数寄存器](reg.png)
* 字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，64位操作可以访问整个寄存器
* `%esp`栈指针，用来指明运行时栈的结束位置
* `$-16` - 立即数，用来表示数值

### 条件码
|条件码|作用|
|-----|----
|CF(carry flag)|进位标志，最近的操作使最高位产生进位，可用来检查无符号操作的溢出
|ZF(zero flag)| 零标志，最近的操作得出的结果为0
|SF(sign flag)| 最近的操作得到的结果为0
|OF(overflow flag)| 溢出标志，最近的操作导致一个补码溢出-正溢出或负溢出

* `set` set指令的目的操作数是低位单字节寄存器元素之一，或是一个直接的内存位置

### 跳转
*jmp*
* 跳转是相对于跳转指令后面的那条指令的地址来进行相对寻址的。
* 目标地址 - 基准地址
* `rep ret` 中rep后跟ret的组合来避免使ret的指令称为条件跳转指令的目标

### 结构
```c
/*这个结构总共需要24字节，type为4字节，填充4字节，info。internal为16字节。*/
typedef enum {N_LEAF, N_INTERNAL} nodetype_t;

struct node_t {
    nodetype_t type;
    union {
        struct {
            struct node_t *left;
            struct node_t *right;
        } internal;
        double data[2];
    } info;
}
```
`&` 表示当前的地址

### 栈上的局部存储
* 寄存器不足够存放所有的本地数据
* 对一个局部变量使用地址运算符'&',因此必须能为它产生一个地址
* 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。、